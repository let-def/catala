rule syntax_error = parse error
  | /option(preceded(CONTENT,addpos(typ))): CONTENT . typ_data
    { "expected a content type" }

  | /enum_decl_line: ALT UIDENT . option(preceded(CONTENT,addpos(typ)))
    { "expected a payload for your enum case, or another case or declaration" }

  | [_ /list(addpos(enum_decl_line)): enum_decl_line . list(addpos(enum_decl_line))]
    { "expected another enum case, or a new declaration or scope use" }

  | /enum_decl_line: ALT . UIDENT option(preceded(CONTENT,addpos(typ)))
    { "expected the name of an enum case" }

  | /code_item: DECLARATION ENUM UIDENT COLON . list(addpos(enum_decl_line))
    { "expected an enum case" }

  | /code_item: DECLARATION ENUM UIDENT . COLON list(addpos(enum_decl_line))
    { "expected a colon" }

  | /code_item: DECLARATION ENUM . UIDENT COLON list(addpos(enum_decl_line))
    { "expected the name of your enum" }

  | /code_item: DECLARATION SCOPE UIDENT COLON . nonempty_list(addpos(scope_decl_item))
    { "expected a context item introduced by \"context\"" }

  | /code_item: DECLARATION SCOPE UIDENT . COLON nonempty_list(addpos(scope_decl_item))
    { "expected a colon followed by the list of context items of this scope" }

  | /code_item: DECLARATION SCOPE . UIDENT COLON nonempty_list(addpos(scope_decl_item))
    { "expected the name of the scope you are declaring" }

  | /struct_scope: struct_scope_base DEPENDS . separated_nonempty_list(COMMA,var_content)
    /struct_scope: struct_scope_base DEPENDS . LPAREN separated_nonempty_list(COMMA,var_content) RPAREN
    { "expected the type of the parameter of this struct data function" }

  | [_ /struct_scope: struct_scope_base . DEPENDS separated_nonempty_list(COMMA,var_content)
       /struct_scope: struct_scope_base . DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN
       /struct_scope: struct_scope_base . ]
    { "expected a new struct data, or another declaration or scope use" }

  | /struct_scope_base: CONDITION . lident
    { "expected the name of this struct condition" }

  | /struct_scope_base: DATA lident CONTENT . typ_data
    { "expected the type of this struct data" }

  | [_ /struct_scope_base: DATA lident . CONTENT typ_data]
    { "expected the type of this struct data, introduced by the content keyword" }

  | /struct_scope_base: DATA . lident CONTENT typ_data
    { "expected the name of this struct data" }

  | /code_item: DECLARATION STRUCT UIDENT COLON . list(addpos(struct_scope))
    { "expected struct data or condition" }

  | /code_item: DECLARATION STRUCT UIDENT . COLON list(addpos(struct_scope))
    { "expected a colon" }

  | /code_item: DECLARATION STRUCT . UIDENT COLON list(addpos(struct_scope))
    { "expected the struct name" }

  | /code_item: DECLARATION . STRUCT UIDENT COLON list(addpos(struct_scope))
    /code_item: DECLARATION . SCOPE UIDENT COLON nonempty_list(addpos(scope_decl_item))
    /code_item: DECLARATION . ENUM UIDENT COLON list(addpos(enum_decl_line))
    /code_item: DECLARATION . lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS expression
    /code_item: DECLARATION . lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
    /code_item: DECLARATION . lident CONTENT typ_data DEFINED_AS expression
    { "expected the kind of the declaration (struct, scope or enum)" }

  | /assertion: FIXED separated_nonempty_list(DOT,addpos(LIDENT)) BY . lident
    { "expected the legislative text by which the value of the variable is fixed" }

  | [_ /assertion: FIXED separated_nonempty_list(DOT,addpos(LIDENT)) . BY lident]
    { "expected the legislative text by which the value of the variable is fixed" }

  | /assertion: FIXED . separated_nonempty_list(DOT,addpos(LIDENT)) BY lident
    { "expected the name of the variable that should be fixed" }

  | [_ /condition_consequence: UNDER_CONDITION expression . CONSEQUENCE]
    { "expected a consequence for this definition under condition" }

  | /condition_consequence: UNDER_CONDITION . expression CONSEQUENCE
    { "expected an expression for this condition" }

  | [_ /assertion: VARIES separated_nonempty_list(DOT,addpos(LIDENT)) . WITH_V expression option(addpos(variation_type))]
    { "expected an indication about what this variable varies with" }

  | /assertion: VARIES separated_nonempty_list(DOT,addpos(LIDENT)) WITH_V . expression option(addpos(variation_type))
    { "the variable varies with an expression that was expected here" }

  | /assertion: VARIES . separated_nonempty_list(DOT,addpos(LIDENT)) WITH_V expression option(addpos(variation_type))
    { "expecting the name of the varying variable" }

  | /scope_item: ASSERTION . assertion
    { "expected an expression that shoud be asserted during execution" }

  | /definition: option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT))
                  option(addpos(definition_parameters)) option(state) option(condition_consequence)
                  DEFINED_AS . expression
    { "expected an expression for the definition" }

  | [_ /separated_nonempty_list(COMMA,lident): lident . COMMA separated_nonempty_list(COMMA,lident)]
    { "expected an expression for defining this function, introduced by the defined as keyword ; or a comma followed by another argument" }

  | [_ /definition: option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT)) .
                    option(addpos(definition_parameters)) option(state) option(condition_consequence) DEFINED_AS expression]
    { "expected the defined as keyword to introduce the definition of this variable" }

  | /definition: option(label) option(exception_to) DEFINITION . separated_nonempty_list(DOT,addpos(LIDENT))
                  option(addpos(definition_parameters)) option(state) option(condition_consequence) DEFINED_AS expression
    { "expected the name of the variable you want to define" }

  | /exception_to: EXCEPTION . option(lident)
    { "expected the label to which the exception is referring back" }

  | [_ /option(addpos(exception_to)): exception_to .
       /option(exception_to): exception_to .]
    {"expected a rule or a definition after the exception declaration" }

  | [_ /definition: option(label) . option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT)) option(addpos(definition_parameters)) option(state) option(condition_consequence) DEFINED_AS expression
       / \rule: option(label) . option(addpos(exception_to)) RULE rule_expr option(state) option(condition_consequence) rule_consequence]
    { "expected a rule or a definition after the label declaration" }

  | /label: LABEL . lident
    { "expected the name of the label" }

  | /separated_nonempty_list(DOT,addpos(LIDENT)): LIDENT DOT . separated_nonempty_list(DOT,addpos(LIDENT))
    { "expected a struct field or a sub-scope context item after the dot" }

  | [_ /rule_consequence: option(NOT) . FILLED]
    { "expected the filled keyword the this rule" }

  | /definition_parameters: OF . separated_nonempty_list(COMMA,lident)
    { "expected the name of the parameter for this dependent variable" }

  | /separated_nonempty_list(DOT,addpos(LIDENT)): LIDENT . DOT separated_nonempty_list(DOT,addpos(LIDENT))
    { "expected a condition or a consequence for this rule, or the rest of the variable qualified name" }

  | [_ /rule_expr: separated_nonempty_list(DOT,addpos(LIDENT)) . option(addpos(definition_parameters))]
    { "expected a condition or a consequence for this rule" }

  | / \rule: option(label) option(addpos(exception_to)) RULE . rule_expr option(state) option(condition_consequence) rule_consequence
    { "expected the name of the variable subject to the rule" }

  | /code_item: SCOPE UIDENT option(preceded(UNDER_CONDITION,expression)) COLON . nonempty_list(scope_item)
    { "expected a scope use item: a rule, definition or assertion" }

  | /expression: UIDENT . DOT qlident
    /quident: UIDENT . DOT quident
    { "expected a payload for the enum case constructor, or the rest of the expression (with an operator ?)" }

  | [_ / expression: EXISTS lident . AMONG expression SUCH THAT expression]
    { "expected the \"in\" keyword to continue this existential test" }

  | /expression: EXISTS . lident AMONG expression SUCH THAT expression
    { "expected an identifier that will designate the existential witness for the test" }

  | [_ /expression: FOR ALL lident . AMONG expression WE_HAVE expression]
    { "expected the \"in\" keyword for the rest of the universal test" }

  | /expression: FOR ALL . lident AMONG expression WE_HAVE expression
    { "expected an identifier for the bound variable of the universal test" }

  | /expression: FOR . ALL lident AMONG expression WE_HAVE expression
    { "expected the \"all\" keyword to mean the \"for all\" construction of the universal test" }

  | [_ /expression: IF expression . THEN expression ELSE expression]
    { "expected the \"then\" keyword as the conditional expression is complete" }

  | INT_LITERAL /literal: INT_LITERAL . option(addpos(unit_literal))
    { "expected a unit for this literal, or a valid operator to complete the expression" }

  | LPAREN; [expression /expression: LPAREN expression . RPAREN]
    { "unmatched parenthesis that should have been closed by here" }

  | LPAREN /expression: LPAREN . expression RPAREN
   { "expected an expression inside the parenthesis" }

  | [_ /separated_nonempty_list(SEMICOLON,expression): expression . SEMICOLON separated_nonempty_list(SEMICOLON,expression)]
    { "expected a semicolon or a right square bracket after the collection element" }

  | LBRACKET /expression: LBRACKET . loption(separated_nonempty_list(SEMICOLON,expression)) RBRACKET
    { "expected a collection element" }

  | /nonempty_list(addpos(preceded(ALT,match_arm))): ALT . match_arm nonempty_list(addpos(preceded(ALT,match_arm)))
    { "expected the name of the constructor for the enum case in the pattern matching" }

  | /expression: expression WITH . constructor_binding
    /expression: MATCH expression WITH . nonempty_list(addpos(preceded(ALT,match_arm)))
    { "expected a pattern matching case" }

  | /expression: MATCH . expression WITH nonempty_list(addpos(preceded(ALT,match_arm)))
    { "expected an expression to match with" }

  | /code_item: SCOPE UIDENT . option(preceded(UNDER_CONDITION,expression)) COLON nonempty_list(scope_item)
    { "expected a scope use condition or the content of this scope use" }

  | /code_item: SCOPE . UIDENT option(preceded(UNDER_CONDITION,expression)) COLON nonempty_list(scope_item)
    { "expected the name of the scope being used" }

  | /source_file_item: BEGIN_CODE . code END_CODE
    { "expected some declaration or scope use inside this code block" }

  | /nonempty_list(LAW_TEXT): LAW_TEXT . nonempty_list(LAW_TEXT)
    { "expected some law text or code block" }

  | /source_file': . source_file
    { "expected some law text or code block" }

  | /metadata_block: BEGIN_METADATA . option(law_text) code END_CODE
    { "expected some law text or code block" }

  | [option(law_text) / metadata_block: BEGIN_METADATA option(law_text) . code END_CODE]
    { "expected some law text or code block" }

  | /expression: UIDENT DOT . qlident
    /quident:    UIDENT DOT . quident
    { "expected an identifier (variable name, structure field or enumeration constructor, possibly with a submodule qualification)" }

  | /qlident: UIDENT . DOT qlident
    /quident: UIDENT . DOT quident
    { "expected one of:\n\
       - a dot followed by an identifier ('Path.And.var')\n\
       - or a structure content ('Structname { -- field1: ... }')\n\
       - or enumeration content ('EnumConstr content ...')" }

  | /qlident: UIDENT DOT . qlident
    /quident: UIDENT DOT . quident
    { "expected an identifier (variable name, structure field or enumeration constructor, possibly with a submodule qualification)" }

  | /expression: SUM . primitive_typ OF expression
    { "the 'sum' operator must be followed by the type to be summed." }

  | /quident: UIDENT DOT . quident
    { "expected the structure or enumeration type of the definition under the given module." }

  | [_ /expression: SUM primitive_typ . OF expression]
    { "expected 'of' then the collection on which to operate" }

  | /expression: SUM primitive_typ OF . expression
    { "expected the collection on which to operate the sum" }

  | /expression: OUTPUT . OF quident option(scope_call_args)
    { "expected 'of' then a scope to be applied" }

  | /expression: OUTPUT OF . quident option(scope_call_args)
    { "expected a scope to be applied" }

  | [_ /expression: OUTPUT OF quident . option(scope_call_args)]
    { "expected 'with' then the arguments to the scope call ('{ -- var : ... }'), or a binary operator to be applied on the results of the call" }

  | /option(scope_call_args): WITH_V . LBRACE list(preceded(ALT,struct_content_field)) RBRACE
    { "expected the arguments to the scope call ('{ --var: ... }')" }

  | LBRACE /option(scope_call_args): WITH_V LBRACE . list(preceded(ALT,struct_content_field)) RBRACE
    { "expected a list of variable-value bindings in the form `-- var_name : <expression>`" }

  | /list(preceded(ALT,struct_content_field)): ALT . struct_content_field list(preceded(ALT,struct_content_field))
    { "expected a variable name, following the form '-- var_name : <expression>'" }

  | [_ /struct_content_field: lident . COLON expression]
    { "expected a colon, following the form '-- var_name : <expression>'" }

  | /struct_content_field: lident COLON . expression
    { "expected an expression, following the form '-- var_name : <expression>'" }

  | /expression: NOT . expression
    { "expected a boolean expression to apply 'not' on" }

  | MINUS /expression: MINUS . expression
    { "expected a numeric expression to apply '-' on" }

  | /expression: MINIMUM . OF expression OR IF COLLECTION EMPTY THEN expression
  | /expression: MAXIMUM . OF expression OR IF COLLECTION EMPTY THEN expression
    { "expected 'of' then the collection to operate on" }

  | /expression: MINIMUM OF . expression OR IF COLLECTION EMPTY THEN expression
  | /expression: MAXIMUM OF . expression OR IF COLLECTION EMPTY THEN expression
    { "expected an expression defining the collection to operate on" }

  | /expression: LET . lident DEFINED_AS expression IN expression
    { "expected 'var equals expression' after 'let'" }

  | [_ / expression: LET lident . DEFINED_AS expression IN expression]
    { "expected 'equals expression' after 'let'" }

  | /expression: FOR ALL lident AMONG . expression WE_HAVE expression
  | /expression: EXISTS lident AMONG . expression SUCH THAT expression
    { "expected an expression describing the collection to operate on" }

  | /literal: DECIMAL_LITERAL . option(addpos(unit_literal))
    { "expected binary operator" }

  | /expression: quident LBRACE . nonempty_list(preceded(ALT,struct_content_field)) RBRACE
    { "expected a list of field bindings of the form '-- fld : expression'" }

  | /nonempty_list(preceded(ALT,struct_content_field)): ALT . struct_content_field nonempty_list(preceded(ALT,struct_content_field))
    { "expected a 'fldname : expression' binding" }

  | /option(preceded(CONTENT,expression)): CONTENT . expression
    { "expected an expression defining the enumeration case content" }

  | /expression: lident AMONG . expression SUCH THAT expression IS MAXIMUM OR IF COLLECTION EMPTY THEN expression
    /expression: lident AMONG . expression SUCH THAT expression IS MINIMUM OR IF COLLECTION EMPTY THEN expression
    { "expected an expression defining a collection" }

  | [_ /expression: lident AMONG expression . SUCH THAT expression IS MAXIMUM OR IF COLLECTION EMPTY THEN expression
       /expression: lident AMONG expression . SUCH THAT expression IS MINIMUM OR IF COLLECTION EMPTY THEN expression]
    { "expected 'such that <expression>'" }

  | /expression: expression XOR . expression
    { "expected a boolean expression" }

  | /expression: expression WITH . constructor_binding
    { "expected a pattern to match against" }

  | /constructor_binding: quident OF . lident
    { "expected an ident, as in the form 'with pattern <Case> of <ident> and <expr>'" }

  | /expression: expression PLUSPLUS . expression
    { "expected a collection expression" }

  | /expression: expression OF . funcall_args
    { "expected an expression specifying the function argument" }

  | /expression: expression FOR . lident AMONG expression SUCH THAT expression
    { "expected an identifier as in the form '<expression> for <ident> among <expression>'" }

  | [_ /expression: expression FOR lident . AMONG expression SUCH THAT expression]
    { "expected 'in', as in the form '<expression> for <ident> among <expression>'" }

  | /expression: expression FOR lident AMONG . expression SUCH THAT expression
    { "expected an expression defining a collection" }

  | [_ /expression: expression FOR lident AMONG expression . SUCH THAT expression]
    { "expected 'such that <expression>', or a binary operator continuing the expression, or a keyword ending the expression and starting the next item" }

  | /expression: expression FOR lident AMONG expression SUCH . THAT expression
    { "expected the form 'such that <expression>'" }

  | /expression: expression FOR lident AMONG expression SUCH THAT . expression
    { "expected an expression defining the condition to apply to the elements of the collection" }

  | /expression: expression DOT . qlident
    { "expected a structure field or sub-scope variable name" }

  | /qlident: UIDENT . DOT qlident
    { "expected a dot forming a module path, as in 'Module.variable', or a binary operator continuing the expression, or a keyword ending the expression and starting the next item" }

  | /qlident: UIDENT DOT . qlident
    { "expected a module path, as in 'Module.Submodule.variable'" }

  | /expression: lident AMONG expression SUCH . THAT expression IS MAXIMUM OR IF COLLECTION EMPTY THEN expression
    /expression: lident AMONG expression SUCH . THAT expression IS MINIMUM OR IF COLLECTION EMPTY THEN expression
    { "expected the form '<var> among <expression> such that <expression>'" }

  | /expression: lident AMONG expression SUCH THAT . expression IS MAXIMUM OR IF COLLECTION EMPTY THEN expression
    /expression: lident AMONG expression SUCH THAT . expression IS MINIMUM OR IF COLLECTION EMPTY THEN expression
    { "expected the form '<var> among <expression> such that <expression>'" }

  | /expression: lident AMONG expression SUCH THAT expression IS . MAXIMUM OR IF COLLECTION EMPTY THEN expression
    /expression: lident AMONG expression SUCH THAT expression IS . MINIMUM OR IF COLLECTION EMPTY THEN expression
    { "expected 'maximum' or 'minimum'" }

  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM . OR IF COLLECTION EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM . OR IF COLLECTION EMPTY THEN expression
    { "expected 'or if collection empty then <expression>'" }

  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR IF COLLECTION EMPTY THEN . expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR IF COLLECTION EMPTY THEN . expression
    { "expected an expression, following the form 'or if collection empty then <expression>'" }

  | [_ /expression: EXISTS lident AMONG expression . SUCH THAT expression]
    { "expected 'such that <expression>'" }

  | /expression: EXISTS lident AMONG expression SUCH . THAT expression
    { "expected the form 'such that <expression>'" }

  | /expression: EXISTS lident AMONG expression SUCH THAT . expression
    { "expected an expression, following the form 'such that <expression>'" }

  | [_ /expression: FOR ALL lident AMONG expression . WE_HAVE expression]
    { "expected 'we have <expression>'" }

  | /expression: FOR ALL lident AMONG expression WE_HAVE . expression
    { "expected the form 'we have <expression>'" }

  | /expression: IF expression THEN . expression ELSE expression
    { "expected an expression, followed by 'else <expression>'" }

  | [_ /expression: IF expression THEN expression . ELSE expression]
    { "expected 'else <expression>'" }

  | [_ /expression: LET lident DEFINED_AS expression . IN expression]
    { "expected the keyword 'in'" }

  | [_ /expression: MATCH expression . WITH nonempty_list(addpos(preceded(ALT,match_arm)))]
    { "expected 'with pattern -- <pattern> : <expression> ...'" }

  | /match_arm: WILDCARD . COLON expression
    { "expected ':' followed by an expression" }

  | [_ /match_arm: constructor_binding COLON expression .]
    { "expected a binary operator, or the next case in the form '-- NextCase : <expression>', or a keyword ending the match expression and starting the next item" }

  | [_ /expression: MAXIMUM OF expression . OR IF COLLECTION EMPTY THEN expression]
    { "expected 'or if collection empty then <expression>'" }

  | /expression: MAXIMUM OF expression OR IF COLLECTION EMPTY THEN . expression
    { "expected an expression, following the form 'or if collection empty then <expression>'" }

  | [_ /expression: MINIMUM OF expression . OR IF COLLECTION EMPTY THEN expression]
    { "expected 'or if collection empty then <expression>'" }

  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR . IF COLLECTION EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR . IF COLLECTION EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR IF . COLLECTION EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR IF . COLLECTION EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR IF COLLECTION . EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR IF COLLECTION . EMPTY THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR IF COLLECTION EMPTY . THEN expression
  | /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR IF COLLECTION EMPTY . THEN expression
  | /expression: MAXIMUM OF expression OR . IF COLLECTION EMPTY THEN expression
  | /expression: MAXIMUM OF expression OR IF . COLLECTION EMPTY THEN expression
  | /expression: MAXIMUM OF expression OR IF COLLECTION . EMPTY THEN expression
  | /expression: MAXIMUM OF expression OR IF COLLECTION EMPTY . THEN expression
  | /expression: MINIMUM OF expression OR . IF COLLECTION EMPTY THEN expression
  | /expression: MINIMUM OF expression OR IF . COLLECTION EMPTY THEN expression
  | /expression: MINIMUM OF expression OR IF COLLECTION . EMPTY THEN expression
  | /expression: MINIMUM OF expression OR IF COLLECTION EMPTY . THEN expression
    { "expected the form 'or if collection empty then <expression>'" }

  | /expression: MINIMUM OF expression OR IF COLLECTION EMPTY THEN . expression
    { "expected an expression, following the form 'or if collection empty then <expression>'" }

  | /expression: IF . expression THEN expression ELSE expression
    { "expected an expression for the test of the conditional" }

  | [expression /struct_content_field: lident COLON expression .]
    { "expected another field in the form '-- <var>: <expression>', or a closing '}' brace" }

  | [_ /assertion: option(condition_consequence) . expression]
  | [_ / \rule: option(label) option(addpos(exception_to)) RULE rule_expr option(state) option(condition_consequence) . rule_consequence]
    { "expected either 'fulfilled' or 'not fulfilled'" }

  | /state: STATE . lident
    { "expected an identifier defining the name of the state" }

  | [_ / \rule: option(label) option(addpos(exception_to)) RULE rule_expr option(state) . option(condition_consequence) rule_consequence]
  | [_ /definition: option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT)) option(addpos(definition_parameters)) option(state) . option(condition_consequence) DEFINED_AS expression]
    { "expected 'equals' then an expression defining the rule" }

  | [_ /definition: option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT)) option(addpos(definition_parameters)) option(state) option(condition_consequence) . DEFINED_AS expression]
    { "expected 'fulfilled' or 'not fulfilled'" }

  | [_ /scope_decl_item_attribute: scope_decl_item_attribute_input . scope_decl_item_attribute_output]
    { "expected a variable name, optionally preceded by 'output'" }

  | [_ /scope_decl_item: scope_decl_item_attribute . lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
       /scope_decl_item: scope_decl_item_attribute . lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
       /scope_decl_item: scope_decl_item_attribute . lident CONTENT typ_data list(state)
       /scope_decl_item: scope_decl_item_attribute . lident CONDITION DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
       /scope_decl_item: scope_decl_item_attribute . lident CONDITION DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
       /scope_decl_item: scope_decl_item_attribute . lident CONDITION list(state) ]
    { "expected a variable name" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident . CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
       /scope_decl_item: scope_decl_item_attribute lident . CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
       /scope_decl_item: scope_decl_item_attribute lident . CONTENT typ_data list(state)
       /scope_decl_item: scope_decl_item_attribute lident . CONDITION DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
       /scope_decl_item: scope_decl_item_attribute lident . CONDITION DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
       /scope_decl_item: scope_decl_item_attribute lident . CONDITION list(state)]
    { "expected either 'condition', or 'content' followed by the expected variable type" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data . DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
       /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data . DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
       /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data . list(state)]
    { "expected either 'state' definitions for the variable, or the next declaration for the scope" }

  | /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS . separated_nonempty_list(COMMA,var_content) list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS . LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    { "expected a name and type for the dependency of this definition ('<ident> content <type>')" }

  | /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS LPAREN . separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    { "expected a name and type for the dependency of this definition ('<ident> content <type>')" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) . RPAREN list(state)]
    { "expected a closing paren, or a comma followed by another argument specification" }

  | /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN . list(state)
    { "expected a 'state' declaration for the preceding declaration, or the next declaration for the scope" }

  | [state /list(state): state . list(state)]
    { "expected either another 'state' definitions for the variable, or the next declaration for the scope" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) . list(state)]
    { "expected the next declaration for the scope" }

  | /scope_decl_item: scope_decl_item_attribute lident CONDITION . DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONDITION . DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONDITION . list(state)
    { "expected the next declaration for the scope" }

  | /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS . separated_nonempty_list(COMMA,var_content) list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS . LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    { "expected the form 'depends on <ident> content <type>'" }

  | /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS LPAREN . separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    { "expected the form 'depends on (<ident> content <type> [, <ident> content <type> ...])'" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) . RPAREN list(state)]
    { "expected a closing paren, or a comma followed by another argument declaration (', <ident> content <type>')" }

  | /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN . list(state)
    { "expected the next definition in scope" }

  | [_ /scope_decl_item: scope_decl_item_attribute lident CONDITION DEPENDS separated_nonempty_list(COMMA,var_content) . list(state) ]
    { "expected the next definition in scope, or a comma followed by another argument declaration (', <ident> content <type>')" }

  | [scope_decl_item
     /nonempty_list(addpos(scope_decl_item)): scope_decl_item .
     /nonempty_list(addpos(scope_decl_item)): scope_decl_item . nonempty_list(addpos(scope_decl_item))]
    { "expected the next declaration for the scope" }

  | [lident /scope_decl_item: lident . SCOPE UIDENT]
    { "expected the form '<ident> scope <Scope_name>', or a scope variable declaration" }

  | /scope_decl_item: lident SCOPE . UIDENT
    { "expected a scope name" }

  | [lident
     /code_item: DECLARATION lident . CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS expression
     /code_item: DECLARATION lident . CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
     /code_item: DECLARATION lident . CONTENT typ_data DEFINED_AS expression]
    { "expected 'content <type>'" }

  | /code_item: DECLARATION lident CONTENT typ_data DEPENDS . separated_nonempty_list(COMMA,var_content) DEFINED_AS expression
    /code_item: DECLARATION lident CONTENT typ_data DEPENDS . LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
    { "expected a variable name, following the form 'depends on <var> content <type>'" }

  | /code_item: DECLARATION lident CONTENT typ_data DEPENDS LPAREN . separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
    { "expected a variable name, following the form 'depends on (<var> content <type>, ...)'" }

  | [_ /code_item: DECLARATION lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) . RPAREN DEFINED_AS expression]
    { "expected ')', or ',' followed by another argument declaration in the form '<var> content <type>'" }

  | /code_item: DECLARATION lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN . DEFINED_AS expression
    { "expected 'equals <expression>'" }

  | [_ /separated_nonempty_list(COMMA,var_content): lident . CONTENT typ_data COMMA separated_nonempty_list(COMMA,var_content)]
    { "expected 'content <type>'" }

  | [_ /separated_nonempty_list(COMMA,var_content): lident CONTENT typ_data . COMMA separated_nonempty_list(COMMA,var_content)]
    { "expected 'equals <expression>'" }

  | /separated_nonempty_list(COMMA,var_content): lident CONTENT typ_data COMMA . separated_nonempty_list(COMMA,var_content)
    { "expected the definition of another argument in the form '<var> content <type>'" }

  | [_ /code_item: DECLARATION lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) . DEFINED_AS expression]
    { "expected 'equals <expression>'" }

  | [_ /match_arm: constructor_binding . COLON expression]
    { "expected a colon followed by an expression, as in '-- Case : <expression>'" }

  | [_ /constructor_binding: quident . OF lident]
    { "expected the form 'with pattern <Case> of <ident> and <expr>', or a binary operator continuing the expression, or a keyword ending the expression and starting the next item" }

  | /quident: UIDENT . DOT quident
    { "expected one of\n\
       - a dot specifying the path to the given structure or enumeration ('Path.To.variable')\n\
       - a dependency specification ('depends on ...')\n\
       - the body of the declaration ('equals ...')" }

  | [_ /code_item: DECLARATION lident CONTENT typ_data . DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS expression
       /code_item: DECLARATION lident CONTENT typ_data . DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
       /code_item: DECLARATION lident CONTENT typ_data . DEFINED_AS expression]
    { "expected 'equals <expression>', optionally preceded by 'depends on <var> content <type>'" }

  | /source_file_item: BEGIN_DIRECTIVE . LAW_INCLUDE COLON nonempty_list(DIRECTIVE_ARG) option(AT_PAGE) END_DIRECTIVE
    { "expected a directive, e.g. 'Include: <filename>'" }

  | /source_file_item: BEGIN_DIRECTIVE LAW_INCLUDE . COLON nonempty_list(DIRECTIVE_ARG) option(AT_PAGE) END_DIRECTIVE
    { "expected ':', then a file name or 'JORFTEXTNNNNNNNNNNNN'" }

  | /source_file_item: BEGIN_DIRECTIVE LAW_INCLUDE COLON . nonempty_list(DIRECTIVE_ARG) option(AT_PAGE) END_DIRECTIVE
    { "expected a file name or 'JORFTEXTNNNNNNNNNNNN'" }

  | /nonempty_list(DIRECTIVE_ARG): DIRECTIVE_ARG . nonempty_list(DIRECTIVE_ARG)
    { "expected a page specification in the form '@p.<number>', or a newline" }

  | [nonempty_list(DIRECTIVE_ARG); option(AT_PAGE)
     /source_file_item: BEGIN_DIRECTIVE LAW_INCLUDE COLON nonempty_list(DIRECTIVE_ARG) option(AT_PAGE) . END_DIRECTIVE]
    { "expected a newline" }

  | [source_file_item /source_file: source_file_item . source_file]
    { "expected one of\n\
      - plain text law in markdown format\n\
      - a catala metadata block started with '```catala-metadata'\n\
      - a catala code block started with '```catala'\n\
      - a catala test block started with '```catala-test-inline' or '```catala-test'\n\
      - a directive, e.g. '> Include: <filename>'"
    }

  | /scope_decl_item: scope_decl_item_attribute lident CONTENT . typ_data DEPENDS separated_nonempty_list(COMMA,var_content) list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONTENT . typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN list(state)
    /scope_decl_item: scope_decl_item_attribute lident CONTENT . typ_data list(state)
  | /code_item: DECLARATION lident CONTENT . typ_data DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS expression
    /code_item: DECLARATION lident CONTENT . typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression
    /code_item: DECLARATION lident CONTENT . typ_data DEFINED_AS expression
  | /separated_nonempty_list(COMMA,var_content): lident CONTENT . typ_data COMMA separated_nonempty_list(COMMA,var_content)
    { "expected a type" }

  | /expression: expression PLUS . expression
  | /expression: expression MULT . expression
  | /expression: expression CONTAINS . expression
  | /expression: expression DIV . expression
  | /expression: expression NOT_EQUAL . expression
  | /expression: expression MINUS . expression
  | /expression: expression LESSER_EQUAL . expression
  | /expression: expression LESSER . expression
  | /expression: expression GREATER_EQUAL . expression
  | /expression: expression GREATER . expression
  | /expression: expression EQUAL . expression
  | /expression: expression AND . expression
  | /expression: expression OR . expression
  | /expression: IF expression THEN expression ELSE . expression
  | /expression SEMICOLON . separated_nonempty_list(SEMICOLON,expression)
  | /expression: LET lident DEFINED_AS expression IN . expression
  | /expression: LET lident DEFINED_AS . expression IN expression
  | /match_arm: WILDCARD COLON . expression
  | /match_arm: constructor_binding COLON . expression
  | /option(preceded(UNDER_CONDITION,expression)): UNDER_CONDITION . expression
  | /code_item: DECLARATION lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS . expression
  | /code_item: DECLARATION lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS . expression
    { "expected an expression" }

  | [_ /expression: expression XOR expression .]
  | [_ /expression: expression PLUSPLUS expression .]
  | [_ /funcall_args: expression . /funcall_args: expression . COMMA funcall_args]
  | [_ /expression: expression FOR lident AMONG expression SUCH THAT expression .]
  | [_ /expression: expression PLUS expression .]
  | [_ /expression: expression MULT expression .]
  | [_ /expression: expression CONTAINS expression .]
  | [_ /expression: expression DIV expression .]
  | [_ /expression: expression OR expression .]
  | [_ /expression: expression NOT_EQUAL expression .]
  | [_ /expression: expression MINUS expression .]
  | [_ /expression: expression LESSER_EQUAL expression .]
  | [_ /expression: expression LESSER expression .]
  | [_ /expression: expression GREATER_EQUAL expression .]
  | [_ /expression: expression GREATER expression .]
  | [_ /expression: expression EQUAL expression .]
  | [_ /expression: expression AND expression .]
  | [_ /expression: lident AMONG expression SUCH THAT expression .]
  | [_ /expression: lident AMONG expression SUCH THAT expression IS MINIMUM OR IF COLLECTION EMPTY THEN expression .]
  | [_ /expression: lident AMONG expression SUCH THAT expression IS MAXIMUM OR IF COLLECTION EMPTY THEN expression .]
  | [_ /option(preceded(CONTENT,expression)): CONTENT expression .]
  | [_ /expression: EXISTS lident AMONG expression SUCH THAT expression .]
  | [_ /expression: FOR ALL lident AMONG expression WE_HAVE expression .]
  | [_ /expression: IF expression THEN expression ELSE expression .]
  | [_ /expression: LET lident DEFINED_AS expression IN expression .]
  | [_ /match_arm: WILDCARD COLON expression .]
  | [_ /expression: MAXIMUM OF expression OR IF COLLECTION EMPTY THEN expression .]
  | [_ /expression: MINIMUM OF expression OR IF COLLECTION EMPTY THEN expression .]
  | [_ /expression: MINUS expression .]
  | [_ /expression: NOT expression .]
  | [_ /expression: SUM primitive_typ OF expression .]
  | [_ /assertion: VARIES separated_nonempty_list(DOT,addpos(LIDENT)) WITH_V expression . option(addpos(variation_type))]
  | [_ /definition: option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,addpos(LIDENT)) option(addpos(definition_parameters)) option(state) option(condition_consequence) DEFINED_AS expression .]
  | [_ /code_item: DECLARATION lident CONTENT typ_data DEPENDS LPAREN separated_nonempty_list(COMMA,var_content) RPAREN DEFINED_AS expression .]
  | [_ /code_item: DECLARATION lident CONTENT typ_data DEPENDS separated_nonempty_list(COMMA,var_content) DEFINED_AS expression .]
  | /expression: LIDENT . /lident: LIDENT .
    { "expected a binary operator continuing the expression, or a keyword ending the expression and starting the next item" }

  | [_ /option(preceded(UNDER_CONDITION,expression)): UNDER_CONDITION expression .]
    { "expected the function application operator" }

  | [_ /assertion: option(condition_consequence) expression .]
    { "expected a new scope use item" }

  | [_ /nonempty_list(scope_item): scope_item .
       /nonempty_list(scope_item): scope_item . nonempty_list(scope_item)]
    { "expected the next item in the scope, or the start of a new top-level decleration" }
